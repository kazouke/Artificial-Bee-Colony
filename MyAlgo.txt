#ifndef ABC_H
#define ABC_H

#include <iostream>
#include <vector>
#include <cmath>

#include "Solution.h"
#include "SetUpParams.h"

class Problem;

struct particle // index of a particle in the swarm and its fitness
{
    int index;
    double fitness;
};

class ABC
{
	public:
O		ABC(const Problem& pbm,const SetUpParams& setup); 
O		~ABC();

//~		friend 	ostream& operator<< (ostream& os, const ABC& myAlgo);								//
//~		friend 	istream& operator>> (istream& is, ABC& myAlgo);										//
//X		ABC& operator= (const ABC& myAlgo);															//
O		const SetUpParams& setup() const;															// retourne les paramètres
O	  	void initialize();	//Revoir																//
 
		// creates a array with fitness of all solutions in ABC and its position in the ABC
O       void evaluate();	//Revoir																//
	 
O	 	const vector<Solution*>& solutions() const;													//
O		int upper_cost() const;																		//
O		int lower_cost() const;																		//
O		Solution& solution(const int index) const;													//
O       vector<struct particle>&  fitness_values();													//
O		double fitness(const int index) const;														//
         
		 
O		double best_cost() const;																	//
O		double worst_cost() const;																	//
//X		Solution& best_solution() const;															//
//X		Solution& worst_solution() const;															//
		 
//X		void evolution();																	// makes an evolution step
O		void trier(std::vector<particle> &fitnessValues, std::vector<Solution*> &solutions);		// trie croissant des solutions par rapport à la fitness

	private:
		vector<Solution*> 		d_solutions;     													// individuals in population
		vector<struct particle> d_fitnessValues;													//
		const SetUpParams& 		d_setup;															//
		int 					d_upper_cost,d_lower_cost;											// upper and lower fitness of individuals in population
};

#endif
--------------------------------------------------------------------------------------------------------------------
#include "ABC.h"

ABC::ABC(const Problem& pbm,const SetUpParams& setup):d_solutions(), d_fitnessValues(), d_setup(setup), d_upperCost(), d_lowerCost()
{
	d_solutions.resize(0);
	d_fitnessValues.resize(0);
	d_solutions.resize(d_setup.populationSize());
	d_fitnessValues.resize(d_setup.populationSize());
	for(int i=0;i<d_setup.populationSize();++i)
	{
		d_solutions[i]=new Solution{pbm};	//ajoute une solution au problème passé en paramètre
        d_fitnessValues[i]=particle {.index=i,.fitness=d_solutions.back()->calFitness()};	//ajoute la fitness de la dernière solution
	}
	trier(d_fitnessValues,d_solutions); //trie les solutions par rapport à la fitness, croissant
}

ABC::~ABC()
{
	for(int i=0;i<d_solutions.size();++i)
	{
		delete d_solutions[i];
	}
}

/////////////////////////////////
/*std::ostream& ABC::operator<<(std::ostream& os, const ABC& myAlgo)
{
    for(int i{} ; i < myAlgo.d_solutions.size() ; ++i)
        os << *(myAlgo.d_solutions[i]) << "\n";
    for(int i{} ; i < myAlgo.d_fitnessValues.size() ; ++i)
        os << myAlgo.d_fitnessValues[i].index << " : " << myAlgo.d_fitnessValues[i].fitness << "\n";
    os << myAlgo.d_setup << "\n" << myAlgo.d_upperCost << " " << myAlgo.d_lowerCost;
    return os;
}

std::istream& ABC::operator>>(std::istream& is, ABC& myAlgo)
{
    is >> myAlgo.d_setup;
    return is;
}*/
//////////////////////////////////

const SetUpParams& ABC::setup() const
{
	return d_setup;
}

void ABC::initialize() //renouvelle les solutions
{
	for(int i=0;i<d_solutions.size();++i)
    {
        delete d_solutions[i];
        d_solutions[i] = new Solution{Problem{d_solutions[i]->pbm()}};
		//Revoir
    }
}

void ABC::evaluate()
{
	trier();
    int m=d_solutions.size()/2;
    for (int i = 0; i < m; ++i)
    {
        delete d_solutions[i+m];
        d_solutions[i+m]=new Solution(*d_solutions[i]);
    }
    d_upperCost = d_fitnessValues.size()-1;
    d_lowerCost = 0;
	//Revoir
}

const vector<Solution*>& ABC::solutions() const
{
	return d_solutions;
}

int ABC::upper_cost() const
{
	return d_upperCost;
}

int ABC::lower_cost() const
{
	return d_lowerCost;
}

Solution& ABC::solution(const int index) const
{
	return *(d_solutions[index]);
}

vector<struct particle>&  ABC::fitness_values()
{
	return d_fitnessValues;
}

double ABC::fitness(const int index) const
{
	return d_fitnessValues[index].fitness;
}

double ABC::best_cost() const
{
	return d_solutions[d_lowerCost]->getFitness();
}

double ABC::worst_cost() const
{
	return d_solutions[d_upperCost]->getFitness();
}

Solution& ABC::best_solution() const
{
	
}

Solution& ABC::worst_solution() const
{
	
}

void ABC::evolution() //evolution(int iter), le nombre d'iteration est dans SetUpParams
{
	for (int i=0; i<d_setup.independent_runs(); ++i)
	{
		initialize();
		double fitnessMin=d_solutions[0]->calFitness();
	}
}

void ABC::trier(std::vector<particle> &fitnessValues, std::vector<Solution*> &solutions) //QuickSort
{
    int indice = -1;
    for(int i=0; i<solutions.size(); ++i)
    {
        indice=imin(solutions,i);
        if(indice != i)
        {
            std::swap(solutions[i],solutions[indice]);
            std::swap(fitnessValues[i].index,fitnessValues[indice].index);
        }
    }
}
